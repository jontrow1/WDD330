<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Week 10 Notes</title>
  <meta name="description" content="This is Week 10 Notes of Jon's Portfolio for WDD330">
</head>
<body>
  <header>
    <h1>Jonathan R. Trowbridge - WDD 330 Portfolio</h1>
  </header>
  <nav>

  </nav>
  <main>
    <h2>Week 10 Notes</h2>
    <h3>Validating Forms:</h3>
    <ol>
      <li>Form validation - When you enter data, the browser and/or the web server will check to see that the data is in the correct format and within the constraints set by the application.</li>
      <li>Validation done in the browser is called client-side validation, while validation done on the server is called server-side validation.</li>
      <li>Built-in form validation uses HTML5 form validation features - JavaScript validation is coded using JavaScript.</li>
      <li>Bulit-in: required: Specifies whether a form field needs to be filled in before the form can be submitted.
        minlength and maxlength: Specifies the minimum and maximum length of textual data (strings)
        min and max: Specifies the minimum and maximum values of numerical input types
        type: Specifies whether the data needs to be a number, an email address, or some other specific preset type. 
        pattern: Specifies a regular expression that defines a pattern the entered data needs to follow.</li>
      <li>Most browsers support the Constraint Validation API, which consists of a set of methods and properties available on the following form element DOM interfaces:

          HTMLButtonElement (represents a button element)
          HTMLFieldSetElement (represents a fieldset element)
          HTMLInputElement (represents an input element)
          HTMLOutputElement (represents an output element)
          HTMLSelectElement (represents a select element)
          HTMLTextAreaElement (represents a textarea element)</li>
      <li>The Constraint validation API makes the following properties available on the above elements.

          validationMessage: Returns a localized message describing the validation constraints that the control doesn't satisfy (if any). If the control is not a candidate for constraint validation (willValidate is false) or the element's value satisfies its constraints (is valid), this will return an empty string.
          validity: Returns a ValidityState object that contains several properties describing the validity state of the element. You can find full details of all the available properties in the ValidityState reference page; below is listed a few of the more common ones:
          patternMismatch: Returns true if the value does not match the specified pattern, and false if it does match. If true, the element matches the :invalid CSS pseudo-class.
          tooLong: Returns true if the value is longer than the maximum length specified by the maxlength attribute, or false if it is shorter than or equal to the maximum. If true, the element matches the :invalid CSS pseudo-class.
          tooShort: Returns true if the value is shorter than the minimum length specified by the minlength attribute, or false if it is greater than or equal to the minimum. If true, the element matches the :invalid CSS pseudo-class.
          rangeOverflow: Returns true if the value is greater than the maximum specified by the max attribute, or false if it is less than or equal to the maximum. If true, the element matches the :invalid and :out-of-range CSS pseudo-classes.
          rangeUnderflow: Returns true if the value is less than the minimum specified by the min attribute, or false if it is greater than or equal to the minimum. If true, the element matches the :invalid and :out-of-range CSS pseudo-classes.
          typeMismatch: Returns true if the value is not in the required syntax (when type is email or url), or false if the syntax is correct. If true, the element matches the :invalid CSS pseudo-class.
          valid: Returns true if the element meets all its validation constraints, and is therefore considered to be valid, or false if it fails any constraint. If true, the element matches the :valid CSS pseudo-class; the :invalid CSS pseudo-class otherwise.
          valueMissing: Returns true if the element has a required attribute, but no value, or false otherwise. If true, the element matches the :invalid CSS pseudo-class.
          willValidate: Returns true if the element will be validated when the form is submitted; false otherwise.</li>
      <li>The Constraint Validation API also makes the following methods available on the above elements.

          checkValidity(): Returns true if the element's value has no validity problems; false otherwise. If the element is invalid, this method also fires an invalid event on the element.
          setCustomValidity(message): Adds a custom error message to the element; if you set a custom error message, the element is considered to be invalid, and the specified error is displayed. This lets you use JavaScript code to establish a validation failure other than those offered by the standard HTML5 validation constraints. The message is shown to the user when reporting the problem.</li>
      <li>Customizing these error messages is one of the most common use cases of the constraint validation API.</li>
    </ol>
    
    <h3>Using Fetch:</h3>
    <ol>
      <li>The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses.</li>
      <li>Fetch also provides a single logical place to define other HTTP-related concepts such as CORS and extensions to HTTP.</li>
      <li>The Promise returned from fetch() won’t reject on HTTP error status even if the response is an HTTP 404 or 500.</li>
      <li>fetch() won't receive cross-site cookies; you can’t establish a cross site session using fetch.</li>
      <li>fetch won’t send cookies, unless you set the credentials init option.</li>
      <li>Fetch requests are controlled by the connect-src directive of Content Security Policy rather than the directive of the resources it's retrieving.</li>
      <li>The fetch() method can optionally accept a second parameter, an init object that allows you to control a number of different settings:</li>
      <li>To cause browsers to send a request with credentials included, even for a cross-origin call, add credentials: 'include' to the init object you pass to the fetch() method.</li>
      <li>Use fetch() to POST JSON-encoded data.</li>
      <li>Files can be uploaded using an HTML input type="file"  input element, FormData() and fetch().</li>
      <li>Files can be uploaded using an HTML input type="file" multiple input element, FormData() and fetch().</li>
      <li>An accurate check for a successful fetch() would include checking that the promise resolved, then checking that the Response.ok property has a value of true.</li>
      <li>Instead of passing a path to the resource you want to request into the fetch() call, you can create a request object using the Request() constructor, and pass that in as a fetch() method argument</li>
      <li>The Headers interface allows you to create your own headers object via the Headers() constructor. </li>
      <li>All of the Headers methods throw a TypeError if a header name is used that is not a valid HTTP Header name.</li>
      <li>Both requests and responses may contain body data. </li>
      <li>Fetch API support can be detected by checking for the existence of Headers, Request, Response or fetch() on the Window or Worker scope.</li>
      <li>To use Fetch in unsupported browsers, there is a Fetch Polyfill available that recreates the functionality for non-supporting browsers.</li>
    </ol>
  </main>
  <footer>
    
  </footer>
</body>
</html>